//~~WEBPATH~~/vz-projector/data-provider.js
function ed(a,b,c){Y("Fetching tensor values...","tensors");var d=new XMLHttpRequest;d.open("GET",b);d.responseType="arraybuffer";d.onprogress=function(a){a.lengthComputable&&Y("Fetching tensor values: "+(100*a.loaded/a.total).toFixed(1)+"%","tensors")};d.onload=function(){if(200!==d.status){var b=String.fromCharCode.apply(null,new Uint8Array(d.response));lc(b,"fetching tensors")}else{try{b=new Float32Array(d.response)}catch(k){lc(k,"parsing tensor bytes");return}var g=a.tensorShape[1],h=b.length/
g;a.tensorShape[0]>h&&mc("Showing the first "+h.toLocaleString()+(" of "+a.tensorShape[0].toLocaleString()+" data points"));fd(b,g).then(function(a){c(new ad(a))})}};d.send()}function gd(a,b){hd(a).then(function(a){b(new ad(a))})}function id(a,b){od(a).then(function(a){return b(a)})}
function pd(a,b){var c,d;void 0===c&&(c=1E6);void 0===d&&(d="\n");return new Promise(function(e){function g(m,p){m=new Blob([a.slice(m,m+p)]);p=new FileReader;p.onload=function(a){a=a.target.result;h+=c;a=a.split(d);var m=l+a[0];if(1===a.length)l=m,g(h,c);else{l=a[a.length-1];b(m);for(m=1;m<a.length-1;m++)b(a[m]);h>=k?(l&&b(l),e()):g(h,c)}};p.readAsText(m)}var h=0,k=a.byteLength-1,l="";g(h,c)})}
function hd(a){var b;void 0===b&&(b="\t");Y("Parsing tensors...","tensors");return new Promise(function(c){var d=[],e;pd(a,function(a){a=a.trim();if(""!==a){a=a.split(b);var c={metadata:{},vector:null,index:d.length,projections:null};isNaN(a[0])||e===a.length-1?(c.metadata.label=a[0],c.vector=new Float32Array(a.slice(1).map(Number))):c.vector=new Float32Array(a.map(Number));d.push(c);null==e&&(e=c.vector.length);if(e!==c.vector.length)throw Y("Parsing failed. Vector dimensions do not match"),Error("Parsing failed");
if(1>=e)throw Y("Parsing failed. Found a vector with only one dimension?"),Error("Parsing failed");}}).then(function(){Y(null,"tensors");c(d)})})}function fd(a,b){return Fc("Parsing tensors...",function(){for(var c=a.length/b,d=[],e=0,g=0;g<c;++g)d.push({metadata:{},vector:a.subarray(e,e+b),index:g,projections:null}),e+=b;return d},"tensors").then(function(a){Y(null,"tensors");return a})}
function qd(a,b){var c=a.map(function(a){return{name:a,isNumeric:!0,tooManyUniqueValues:!1,min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}),d=a.map(function(){return{}});b.forEach(function(b){a.forEach(function(a,e){var g=c[e];e=d[e];var h=b[a];null!=h&&(g.tooManyUniqueValues||(h in e?e[h]++:e[h]=1,50<Object.keys(e).length&&(g.tooManyUniqueValues=!0)),isNaN(h)?g.isNumeric=!1:(b[a]=+h,g.min=Math.min(g.min,+h),g.max=Math.max(g.max,+h)))})});c.forEach(function(a,b){a.uniqueEntries=Object.keys(d[b]).map(function(a){return{label:a,
count:d[b][a]}})});return c}function od(a){Y("Parsing metadata...","metadata");return new Promise(function(b){var c=[],d=!1,e=0,g=["label"];pd(a,function(a){if(0!==a.trim().length){if(0===e&&(d=0<=a.indexOf("\t"))){g=a.split("\t");e++;return}e++;var b=a.split("\t"),h={};c.push(h);g.forEach(function(a,c){c=b[c];h[a]=""===c?null:c})}}).then(function(){Y(null,"metadata");b({stats:qd(g,c),pointsInfo:c})})})}
function rd(a){return new Promise(function(b,c){var d=new Image;d.onload=function(){return b(d)};d.onerror=function(a){return c(a)};d.crossOrigin="";d.src=a})}
function sd(a,b,c,d){var e=Promise.resolve({});a&&(e=new Promise(function(b,c){Y("Fetching metadata...","metadata");var d=new XMLHttpRequest;d.open("GET",a);d.responseType="arraybuffer";d.onerror=function(){lc(d.responseText,"fetching metadata");c()};d.onload=function(){b(od(d.response))};d.send(null)}));var g=null,h=null;b&&(g=Y("Fetching sprite image..."),h=rd(b));Promise.all([e,h]).then(function(a){g&&Y(null,g);var b=a[0];(a=a[1])&&(8192<a.height||8192<a.width)?Y("Error: Sprite image of dimensions "+
a.width+"px x "+(a.height+"px exceeds maximum dimensions ")+"8192px x 8192px"):(b.spriteImage=a,b.spriteMetadata=c,d(b))})};